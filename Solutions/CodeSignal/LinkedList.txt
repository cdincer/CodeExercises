----------------------
// Singly-linked lists are already defined with this interface:
// class ListNode<T> {
//   ListNode(T x) {
//     value = x;
//   }
//   T value;
//   ListNode<T> next;
// }
//
ListNode<Integer> removeKFromList(ListNode<Integer> l, int k) {
    if (l == null) {
        return null;
    }

    ListNode<Integer> firstNode = null;
    ListNode<Integer> currentNode = null;
    ListNode<Integer> lastNode = null;

    ListNode<Integer> current = l;

    // iterate through the list, searching for the value k
    while (true) {
        if (current.value != k) {
            // since this node isnt k, set our variables and proceed on
            // set currentNode
            currentNode = current;
            // the set the previous nodes next = this node
            if (lastNode != null) lastNode.next = currentNode;
            // set lastNode to this current node
            lastNode = currentNode;
            // set the first node if it hasnt been set
            if (firstNode == null) firstNode = currentNode;
        }

        // when we hit the end, bail out.
        if (current.next == null) break;
        ListNode<Integer> next = current.next;
        current.next = null;
        current = next;

    }

    return firstNode;
}
-------------------------
// Singly-linked lists are already defined with this interface:
// class ListNode<T> {
//   ListNode(T x) {
//     value = x;
//   }
//   T value;
//   ListNode<T> next;
// }
//
boolean isListPalindrome(ListNode<Integer> l) {
	    ListNode slow = l; ListNode fast = l;
	    while(fast!=null && fast.next!=null){
	        fast= fast.next.next;
	        slow = slow.next;
	    }

	    if(fast!=null){
	        slow= slow.next;
	    }
	    slow = reverse(slow);
	    fast = l;
	    while(slow!=null){
	        int val1=  (int) slow.value;
		    int val2=  (int) fast.value;
	        if(val1!=val2) return false;
	        slow= slow.next;
	        fast= fast.next;
	    }
	    return true;

	}

	public ListNode reverse(ListNode head){
	    ListNode prev = null;
	    while(head!=null){
	        ListNode temp = head.next;
	        head.next= prev;
	        prev= head;
	        head = temp;
	    }
	    return prev;
	}
	------------------------------------------
	addTwoHugeNumbers
	// Singly-linked lists are already defined with this interface:
    // class ListNode<T> {
    //   ListNode(T x) {
    //     value = x;
    //   }
    //   T value;
    //   ListNode<T> next;
    // }
    //
    ListNode<Integer> addTwoHugeNumbers(ListNode<Integer> a, ListNode<Integer> b) {
    	    ListNode<Integer> result = new ListNode<Integer>(0);
    	    ListNode<Integer> head = result;
    	    int carry=0;
    	    a= reverse(a);
    	    b= reverse(b);
    	    while(a!=null || b!=null){
    	        if(a!=null){
    	            carry+= a.value;
    	            a=a.next;
    	        }
    	        if(b!=null){
    	            carry+=b.value;
    	            b= b.next;
    	        }
    	        head.next = new ListNode<Integer>(carry%10000);
    	        head = head.next;
    	        carry = carry/10000;
    	    }
    	    if(carry>=1)
    	        head.next= new ListNode<Integer>(carry);

    	    return reverse(result.next);

    	}

    	ListNode<Integer> reverse(ListNode<Integer> head){
    	    ListNode<Integer> prev =null;
    	    while(head!=null){
    	        ListNode<Integer> temp = head.next;
    	        head.next= prev;
    	        prev= head;
    	        head= temp;
    	    }
    	    return prev;
    	}
-----------------------------------------------------------------

ListNode<Integer> mergeTwoLinkedLists(ListNode<Integer> l1, ListNode<Integer> l2) {
    ListNode<Integer> solu = new ListNode<Integer>(0);
    ListNode<Integer> head = solu;
    if(l1 == null && l2 != null){
        return l2;
    }
    if(l1 != null && l2 == null){
        return l1;
    }
    if(l1 == null && l2 == null){
        return l1;
    }
    while(!(l1 == null && l2 == null)){
        ListNode<Integer> tmp = new ListNode<Integer>(0);
        if(l1 != null && l2 == null){
            solu.value = l1.value;
            if(l1.next != null){
                solu.next = tmp;
                solu = solu.next;
            }
            l1 = l1.next;
        }
        else if(l1 == null && l2 != null){
            solu.value = l2.value;
            if(l2.next != null){
                solu.next = tmp;
                solu = solu.next;
            }
            l2 = l2.next;
        }
        else if(l1.value <= l2.value){
            solu.value = l1.value;
            solu.next = tmp;
            solu = solu.next;
            l1 = l1.next;
        }
        else if(l1.value > l2.value){
            solu.value = l2.value;
            solu.next = tmp;
            solu = solu.next;
            l2 = l2.next;
        }
    }
    return head;
}
-----------------------------------
// Singly-linked lists are already defined with this interface:
// class ListNode<T> {
//   ListNode(T x) {
//     value = x;
//   }
//   T value;
//   ListNode<T> next;
// }
//
ListNode<Integer> reverseNodesInKGroups(ListNode<Integer> l, int k) {
    if(l == null){
        return l;
    }
    ListNode<Integer> tmp = new ListNode<Integer>(0);
    tmp.next = l;
    ListNode<Integer> prev = tmp;
    int i = 0;
    ListNode<Integer> x = l;
    while(x != null){
        i++;
        if(i%k == 0){
            prev = reverse(prev, x.next);
            x = prev.next;
        }
        else{
            x = x.next;
        }
    }
    return tmp.next;
}

ListNode<Integer> reverse(ListNode<Integer> l, ListNode<Integer> j){
    ListNode<Integer> tmp = l.next;
    ListNode<Integer> curr = tmp.next;
    while(curr != j){
        tmp.next = curr.next;
        curr.next = l.next;
        l.next = curr;
        curr = tmp.next;
    }

    return tmp;
}
------------------------------------------
// Singly-linked lists are already defined with this interface:
// class ListNode<T> {
//   ListNode(T x) {
//     value = x;
//   }
//   T value;
//   ListNode<T> next;
// }
//
ListNode<Integer> rearrangeLastN(ListNode<Integer> l, int n) {
	    if(l==null || n==0) return l;
	    ListNode<Integer> temp = l;
	    int len=1;
	    while(temp.next!=null){
	        temp= temp.next;
	        len++;
	    }
	    temp.next = l;
	    n= n%len;
	    for(int i=0; i<(len-n); i++){
	        temp= temp.next;
	    }
	    l= temp.next;
	    temp.next=null;
	    return l;
	}
---------------------------------------